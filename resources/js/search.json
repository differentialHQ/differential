[[{"l":"Differential","p":["Build, Connect and Evolve production services 10x faster with delightful DX!","Differential is in the technical preview stage, and is open-source. We are working hard to make our cloud offering generally available. Sign up for the waitlist here.","Differential is a Service Orchestration Framework that enables developers to turn a set of functions into a typesafe service, without spending additional effort on managing service contracts, network communication, searialization/deserialization service authentication or infrastructure configuration. The latter concerns are completely abstracted away from the developer, and are handled by Differential.","It is designed to:","Lower the barrier to entry for a service-oriented architecture","Make it significantly cheaper to run a service-oriented architecture","Provide a delightful developer experience for building and evolving services"]}],[{"l":"Buiding your first service","p":["Learn to build an end to end Differential app in under 2 minutes with TypeScript and Node.js."]},{"l":"Running the hello world example"},{"l":"1. Set up and Install","p":["Run the following command in your terminal to set up a hello world project","This will:","Clone the Differential app template into a dirctory called my-app","Install the dependencies","Fetch a temporary API secret for you to use and insert it to src/d.ts file","Install the tsx CLI tool globally so you can run ts files directly"]},{"l":"2. Start the hello service","p":["This will start a service called hello and register itself with the Cloud control-plane."]},{"l":"3. Call the running service","p":["This will call the greet command on the hello service and print the result."]},{"l":"Extending the hello service","p":["Let's add a new command to the hello service that will greet someone in a different language, so you can write some code."]},{"l":"1. Add a new function to the hello service","p":["Open up the src/services/hello.ts file and add the following function, under the exising hello function:","As you can see, this function fetches a list of greetings from a fake API and returns the appropriate one. A Differential function can do anything a normal Node.js function can do, including making network requests."]},{"l":"2. Register the function with the service"},{"l":"3. Change the greet command to call the new function","p":["You can replace the greet.ts file with the following. We're just extending the existing command to take a new language parameter and call the new function."]},{"l":"4. Call the new command"}],[{"l":"Thinking in Differential","p":["Differential is a little bit different (pun intended) from the way it looks at separation of services from the way you might be used to.","It's built on the core beliefs that: Monolithic code does not need to result in co-located services.","It's not a RPC framework, or a microservices framework. If you're familiar with a service mesh, you can think of it as a higher-level, app-code aware service mesh."]},{"l":"The Differential Way","p":["1. Services are a collection of functions.","2. There are no restrictions on what these functions can do. They are just functions.","3. All services are co-located in the same codebase, so they can share code and types.","4. Starting a service is as simple as calling d.start(). Stopping is done via a d.stop().","You can have 1:1 services to processes, or you can have multiple services running in the same process. It's up to you. You can also start and stop services dynamically at runtime.","5. Once a service is started, it registers itself with the control-plane.","The open-source control-plane is a central service that keeps track of all the services that are running, and their health. It acts as a service registry, and a service bus.","6. You can call any function in any service from any other service.","You don't need to know where the service is running, or how to connect to it. You just need to know the name of the service and the name of the function.","7. Thanks to co-located code, your function calls are type-safe","You can't call a function that doesn't exist, or pass the wrong arguments.","8. Calling a function has the same ergonomics as calling a local function.","You can just call the function and it will return the result, even if it results in an Error. SDK and the control-plane routes the function call to the correct service, and does the proper serialization and deserialization of arguments and return values."]},{"i":"why","l":"Why?","p":["1. Monolithic codebases provide a great developer experience, but resulting monolithic services often do not.","2. Writing duplicative service interfaces/contracts can be avoided.","3. Anything a service has ever done can and should be represented by a single function definition.","4. Internal services should remain internal.","5. The disadvantages of a centralized control-plane are outweighed by the advantages.","A service bus that is aware of the application code can provide a better developer experience by offering type-safety and a single place to find all the services and their functions.","A service should stay internal until it's ready or necessary to be exposed externally. Starting a service on a port should be a conscious decision, not the default.","A type-safe language that can infer types should be able to infer the contract of a service from the service's implementation.","Communication via queues and pub/sub is a possible alternative, but it introduces complexities such as keeping track of channels:message types, message serialization, message delivery guarantees, and additional infrastructure configuration that lives outside of the code that does the work.","Differential is an opinionated framework. It makes some tradeoffs to make it easier to build services. They might not be the right tradeoffs for you, but we think they are the right tradeoffs for most people.","Every RPC framework introduces more complexity to deal with the impedance mismatch between the language and the wire format.","GraphQL has queries and mutations, but you need complex tooling to generate the types.","In REST, it's hard to model operations that doStuff().","Instead of n services talking to n services, a service bus allows streamlining the communication to a single service and fan-out from there.","Keeping unnecessary services running is wasteful. You can't just run the background processes; you have to run the entire service.","Modern RPC frameworks like gRPC and tRPC solve some of the problems, but they make different tradeoffs for stronger contracts and language/runtime interoperability.","Not having a compile step to generate contracts (e.g., protobufs) or a duplicative interface (tRPC) definition allows you to move faster.","Scaling a single service is hard. You can't scale just the background processes; you have to scale the entire service.","Such an architecture allows for a single place to implement cross-cutting concerns such as authentication, authorization, rate limiting, and observability.","Unless you're very careful, heavy background processes can affect the high availability of your mission-critical services."]}],[{"l":"Concepts"},{"l":"Service","p":["A collection of functions that can be called by a consumer using the differential client. Defined using the SDK."]},{"l":"Host","p":["A computer that you operate and own, that runs your services."]},{"l":"Cluster","p":["A group services that are running on a host. An API key is required to join a cluster."]},{"l":"Control Plane","p":["A central service that keeps track of all the services that are running, and their health. It acts as a service registry, and a service bus."]}],[{"l":"Advanced Usage"},{"l":"End to End Encryption","p":["You might wish to encrypt all function arguments and return values, so that the control plane cannot see them. This is possible with Differential, but it requires you to configure your own encryption keys.","These encryption keys are used to encrypt and decrypt the function arguments and return values. The control plane does not have access to these keys.","The Typescript example below shows how to configure your own encryption keys.","It accepts an array of encryption keys. This is useful if you want to rotate your encryption keys. Differential will try to decrypt the function arguments and return values with each encryption key until it finds one that works."]},{"l":"Idempotency","p":["Idempotency is a property of a function that means that if you call it multiple times with the same arguments, it will always return the same result. This is useful for functions that have side effects, such as sending an email or charging a credit card.","Differential supports idempotency via a convenience function called idempotent. It takes a function and returns a new function that prompts the user to provide an idempotency key. If the function has already been called with that key, it will return the same result as before.","To mark a function as idempotent, simply wrap it with the idempotent function.","Now, when you call the function, you must provide an idempotency key.","If you call the function again with the same idempotency key, the previous result will be returned.","This is helpful when you model your functions as having side effects, such as sending an email or charging a credit card. If you call the function again with the same idempotency key, the side effect will not happen again."]},{"l":"Global Cache","p":["When a function returns a value, Differential will store it in the control-plane state. It's then available to be used by other calls, without having to call the function again. This is useful for caching expensive operations, and speeding up your application.","Differential supports global caching via a convenience function called cached. It takes a function, and a ttl in milliseconds and returns a new function that prompts the user to provide a cache key. If the function has already been called with that key, it will return the same result as before.","To mark a function as cached, simply wrap it with the cached function.","Now, when you call the function, you must provide a cache key.","If you call the function again with the same cache key, the previous result will be returned."]},{"l":"Rate Limiting","p":["Coming soon."]}],[{"l":"Architecture","p":["Differential is currently in technical preview. We've seen promising early results, but our architecture is still evolving. We welcome your thoughts on our design choices. Join the discussion on our GitHub.","Differential’s architecture is intentionally straightforward. We adhere to the principle that simplicity leads to easier scalability, self-hosting, and iterative improvements. Our focus is on refining simplicity to achieve the most effective abstractions."]},{"l":"Key Components","p":["Control Plane","SDK"]},{"l":"Control Plane","p":["The Control Plane functions as the nerve center, handling job management and API interactions. Each function call translates into a job, identified by its name and arguments. The Control Plane dynamically assigns jobs to clients, ensuring a single job isn't processed by multiple clients by atomically updating its state to \"Running\".","To prevent job stalling, the Control Plane monitors job durations, flagging any that exceed predefined limits as failed. These can be retried according to customizable policies. We use a relational database (compatible with Postgres, CockroachDB, etc.) for storing all job states, facilitating self-hosting."]},{"l":"SDK"},{"l":"Service-side","p":["On initializing a service, the SDK registers with the Control Plane and begins polling for jobs. It maintains an in-memory function registry and a task queue. This task queue, whose concurrency level is adjustable, determines parallel function execution capacity.","For each job, the SDK identifies the corresponding function and executes it with the provided arguments. Results are then relayed back to the Control Plane."]},{"l":"Client-side","p":["The client-side of Differential involves invoking functions through a type-safe client established via the SDK. Function calls are serialized and sent to the Control Plane. The client then long-polls for the result, which, upon receipt, is deserialized for use.","In all operations, we use msgpack for its efficiency in serialization over formats like JSON."]},{"l":"Considered Tradeoffs","p":["Long Polling: We chose long polling over persistent connections like websockets for easier self-hosting and scalability of the Control Plane. This decision, while impacting performance, is under continuous evaluation.","Database Selection: Our choice of Postgres for job state storage offers rapid iteration and ease in self-hosting. It strikes a balance between performance and flexibility.","Serialization with Msgpack: Msgpack offers a compact binary format, favoring speed over the compression level achieved by schema-aware binary formats. This decision eliminates the need for intermediate language schemas for developers to maintain."]},{"l":"Future Enhancements and Community Engagement","p":["Differential is a collaborative, evolving project. We actively integrate community feedback into our development process. Future enhancements will focus on improving performance, scalability, and user experience based on real-world applications and user suggestions.","If you're planning to use Differential, we'd love to hear from you. Please reach out to us at hello@differential.dev or join the discussion on our GitHub."]}],[{"l":"Comparisons"},{"i":"comparisons-with-http--rest-apis","l":"Comparisons with HTTP / REST APIs"},{"l":"Working with Data","p":["Unlike REST APIs, with Differential, you don't need to cocern yourself with the HTTP status codes, serialization, or deserialization. Differential works with native data types, and provide type-safe interfaces for you to work with.","This prevents the developer from having to deal with the conversion overhead between programming constructs and HTTP constructs.","With differential, the equivalent code here:","becomes:"]},{"l":"Working with Multiple Services","p":["In a service-oriented architecture, you may have multiple services that you need to communicate with. These will be exposed as different REST APIs, and your clients will communicate with them in a m:m fashion.","With Differential, all your services and clients connect to a single cluster. Clients can access any service that connects to the cluster. How the connections are mapped out, can be traced via the source code without an additional layer of network that gets in the way.","Differential becomes your service gateway and an elegant service discovery mechanism."]},{"l":"Exposure of Internal Functions","p":["A traditional REST service will require you to implement authentication, so your clients have a trusted relationship with your server. This is usually done via a token-based authentication scheme, and middleware that checks for the token on every request. This is especially true if you can't trust the network that your clients are connecting from, such as outside of your VPC.","With Differential, your internal services are only exposed to the control-plane via a secure connection. This means that you don't need to implement authentication for your internal services, as they are not exposed to the outside world. Differential clients can only access the functions that you explicitly expose to them."]},{"l":"Type Safety","p":["Differential provides type-safe interfaces for your clients to interact with your services, without a compile step. This also means that you don't have to worry about intermediate representations like OpenAPI, and the overhead of maintaining them."]},{"l":"Language Agnosticism","p":["Differential is not language agnostic. If you need to connect two services written in different languages, you will need to implement a shim layer in Typescript, and connect them to the same cluster. Depending on your use case, this may be additional complexity that you don't need.","This is in stark contrast to something like a REST service that can publish a intermediary representation of its API, such as OpenAPI, and allow clients to generate code from it. This is a tradeoff that we have made, as we believe that the benefits of type safety outweigh the benefits of language agnosticism."]},{"i":"comparisons-with-grpc--protocol-buffers","l":"Comparisons with gRPC / Protocol Buffers"},{"i":"working-with-data-1","l":"Working with Data","p":["gRPC uses Protocol Buffers as its serialization format. This means that you need to define your data structures in a separate file, and compile them into your language of choice. This is an additional step that you need to perform, and build tooling towards.","Every change that is made to the data structures will require a recompilation of the data structures, and a redeployment of the service.","Differential uses native programming constructs, and does not require you to have a comparative .proto file or a complilation step. Compatibility of contracts is enforced by the type system. However, you do lose out on some of the gurantees that Protocol Buffers provides, such as backwards compatibility.","However, we do plan to support additional developer tooling that will optionally verify and protect against breaking changes in contracts."]},{"l":"Serialization","p":["Protocol Buffers uses its knowledge about the data structure to optimize the serialization, deserialization, and the message size over the wire. Differential does not have this knowledge, and uses msgpack (a binary serialization format) to serialize and deserialize data. This means that the message size over the wire will be typically larger than gRPC, but smaller than JSON."]},{"l":"Other notes","p":["The same notes that apply to REST APIs also apply to gRPC APIs for Working with Multiple Services, Exposure of Internal Functions, Type Safety, and Language Agnosticism."]}],[{"l":"Limitations"},{"l":"Programming language","p":["Differential only supports TypeScript until it gets to a stable release. We do plan to support other languages in the future, however we are intensely focused on creating the right abstractions for a single language first.","There's nothing preventing your from using Differential with JavaScript, however you will lose out on the type safety that Differential provides for your clients."]},{"l":"Function arguments","p":["Although your functions can perform any operation that the JavaScript runtime allows you to perform, there are some limitations on the arguments that you can pass to the functions.","Arguments must be JSON serializable. This means that you can pass strings, numbers, booleans, arrays, objects, and null. You cannot pass functions, promises, or other non-serializable objects.","The reason for this is that the arguments are serialised and msgpacked before being sent to the worker."]},{"l":"Function return values","p":["The return value of your function must also be JSON serializable. This means that you can return strings, numbers, booleans, arrays, objects, and null. You cannot return functions, promises, or other non-serializable objects.","The reason for this is the same as the above."]}],[{"l":"Typescript SDK","p":["This is the official Differential SDK for Typescript."]},{"l":"Installation"},{"l":"npm"},{"l":"yarn"},{"l":"pnpm"},{"l":"Quick Start"},{"l":"1. Initializing Differential","p":["Create a file named d.ts which will be used to initialize Differential. This file will export the Differential instance."]},{"l":"2. Hello World Service","p":["In a separate file, create the \"Hello World\" service. This file will import the Differential instance from d.ts and define the service."]},{"l":"3. Calling the Service","p":["When calling the service, use the typeof generic to ensure type safety. This can be done in any file where you need to call the service, like a test file or another service file."]},{"l":"4. Running the Service","p":["To run the service, simply run the file with the service definition. This will start the service and make it available to other services.","and then you can invoke the service from another file:"]},{"l":"Documentation","p":["Differential documentation contains all the information you need to get started with Differential."]},{"l":"Examples","p":["Monolith contains an example of a monolith application broken into multiple services.","End to end encryption contains an example of how to use Differential's end to end encryption.","Idempotency contains an example of how to use Differential's idempotency."]}],[{"i":"class-differential","l":"Class: Differential","p":["The Differential client. This is the main entry point for using Differential.","Differential client exposes two main methods:","service- Registers a service with Differential. This will register all functions on the service.","client- Provides a type safe client for performing calls to a registered service.","Example"]},{"l":"Table of contents"},{"l":"Constructors","p":["constructor"]},{"l":"Methods","p":["client","service"]},{"i":"constructors-1","l":"Constructors"},{"l":"constructor","p":["• new Differential( apiSecret, options?): Differential","Initializes a new Differential instance."]},{"l":"Parameters","p":["Name","Type","Description","apiSecret","string","The API Secret for your Differential cluster. You can obtain one from https://api.differential.dev/demo/token.","options?","Object","Additional options for the Differential client.","options.encryptionKeys?","Buffer[]","An array of encryption keys to use for encrypting and decrypting data. These keys are never sent to the control-plane and allows you to encrypt function arguments and return values. If you do not provide any keys, Differential will not encrypt any data. Encryption has a performance impact on your functions. When you want to rotate keys, you can add new keys to the start of the array. Differential will try to decrypt data with each key in the array until it finds a key that works. Differential will encrypt data with the first key in the array. Each key must be 32 bytes long.","options.endpoint?","The endpoint for the Differential cluster. Defaults to https://api.differential.dev."]},{"l":"Returns","p":["Differential","Example"]},{"l":"Defined in","p":["ts-core/src/Differential.ts:410"]},{"i":"methods-1","l":"Methods"},{"l":"client","p":["▸ client< T>( service): ServiceClient< T>","Provides a type safe client for performing calls to a registered service. Waits for the function to complete before returning, and returns the result of the function call."]},{"l":"Type parameters","p":["Name","Type","T","extends RegisteredService< any>"]},{"i":"parameters-1","l":"Parameters","p":["Name","Type","service","T[definition][name]"]},{"i":"returns-1","l":"Returns","p":["ServiceClient< T>","ServiceClient","Example"]},{"i":"defined-in-1","l":"Defined in","p":["ts-core/src/Differential.ts:542","▸ client< T>( service, options): BackgroundServiceClient< T>","Provides a type safe client for performing calls to a registered service. Waits for the function to complete before returning, and returns the result of the function call."]},{"i":"type-parameters-1","l":"Type parameters","p":["Name","Type","T","extends RegisteredService< any>"]},{"i":"parameters-2","l":"Parameters","p":["Name","Type","service","T[definition][name]","options","Object","options.background","true"]},{"i":"returns-2","l":"Returns","p":["BackgroundServiceClient< T>","ServiceClient","Example"]},{"i":"defined-in-2","l":"Defined in","p":["ts-core/src/Differential.ts:546"]},{"l":"service","p":["▸ service< T, N>( service): RegisteredService< T>","Registers a service with Differential. This will register all functions on the service."]},{"i":"type-parameters-2","l":"Type parameters","p":["Name","Type","T","extends ServiceDefinition< N>","N","extends string"]},{"i":"parameters-3","l":"Parameters","p":["Name","Type","Description","service","T","The service definition."]},{"i":"returns-3","l":"Returns","p":["RegisteredService< T>","A registered service instance.","Example"]},{"i":"defined-in-3","l":"Defined in","p":["ts-core/src/Differential.ts:518"]}],[{"i":"function-idempotent","l":"Function: idempotent","p":["▸ idempotent< T>( fn): AddParameters< T, [Pick< DifferentialConfig, $idempotencyKey>]>","This is a utility function that makes a function in a service definition idempotent."]},{"l":"Type parameters","p":["Name","Type","T","extends AsyncFunction"]},{"l":"Parameters","p":["Name","Type","Description","fn","T","The function to make idempotent"]},{"l":"Returns","p":["AddParameters< T, [Pick< DifferentialConfig, $idempotencyKey>]>","The same function with the same parameters, but with an additional parameter at the end of the function call that is the idempotency key","Example"]},{"l":"Defined in","p":["ts-core/src/functions.ts:75"]}]]