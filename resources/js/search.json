[[{"l":"Differential","p":["Typescript-first RPC Platform for building effortlessly reliable services","Differential is in the technical preview stage, and is open-source. We are working hard to make our cloud offering generally available. Sign up for the waitlist here.","Differential is an open-source \"Durable RPC\" platform that makes your services more reliable and efficient. By using a centralised control-plane, Differential transparently handles network faults, machine restarts, retries, and more. It comes with end-to-end encryption, observability, service registry, caching, and more without any extra configuration. Moreover, it doesn't change your existing programming paradigm. It acts as a thin wrapper around your existing functions to make them callable from anywhere, with full type safety.","Features"]},{"l":"Reliability","p":["Machine Failure Recovery: If a machine goes down while processing your request, Differential can transparently detect it and retry the operation on a healthy worker. See Compute Recovery for more.","Predictive Retries: With the help of AI Differential detects transient errors (database deadlocks) and retries the operation before the client even notices. See Predictive Retries for more.","Predictive Alerting: Differential can alert you when a function fails due to an unrecoverable error that requires a code change, and provide you with reproduction steps. See Predictive Alerting for more."]},{"l":"Efficiency","p":["Distributed Caching: Differential can transparently cache the results of your function calls from one worker, so that other workers can use the result without recomputing it. See Distributed Caching for more.","On-demand Compute: Use our managed compute offering (in alpha) which will run your services as serverless functions with a single command deploy and significantly less cold-start time. See On-demand Compute for more.","Co-located Code: You can choose to have all your services co-located, and let Differential run them as independent services at run time. No more splitting code for splitting services. See Thinking in Differential for more."]},{"l":"Usability","p":["Use your existing programming paradigm: Differential doesn't invert your programming paradigm. If you know how to write functions, and call them, you already know how to use Differential. A collection of functions is called a service, and services come with lightweight, fully-typesafe clients that you can use to call them from anywhere. See Thinking in Differential for more.","Service Discovery: Differential comes with a built-in service registry, so you can call your services by name, without having to worry about IP addresses, ports, or where it's deployed. Your services phone-home to Differential control-plane. See Service Discovery for more.","Observability: See what's happening in your services in real-time, with end-to-end observability that with zero configuration. See live payloads, events, and errors in the Differential dashboard. See Observability for more."]},{"l":"Open Source and Self-Hostable","p":["Differential is released under the Apache 2.0 license, and can be self-hosted. This means you can run your own control-plane, and have full control over your data and infrastructure. Optionally, you can use Differential Cloud, which is a fully managed offering that we are working hard to make generally available. Sign up for the waitlist here."]},{"l":"Quick Start","p":["Follow the Quick Start guide to get up and running with Differential in under 2 minutes."]},{"i":"see-also","l":"See Also:","p":["Get up and running with Differential in under 2 minutes","Thinking in Differential"]}],[{"l":"Buiding your first service","p":["Learn to build an end to end Differential app in under 2 minutes with TypeScript and Node.js."]},{"l":"Running the hello world example"},{"l":"1. Set up and Install","p":["Run the following command in your terminal to set up a hello world project","This will:","Clone the Differential app template into a dirctory called my-app","Install the dependencies","Fetch a temporary API secret for you to use and insert it to src/d.ts file","Install the tsx CLI tool globally so you can run ts files directly"]},{"l":"2. Start the hello service","p":["This will start a service called hello and register itself with the Cloud control-plane."]},{"l":"3. Call the running service","p":["This will call the greet command on the hello service and print the result."]},{"l":"Extending the hello service","p":["Let's add a new command to the hello service that will greet someone in a different language, so you can write some code."]},{"l":"1. Add a new function to the hello service","p":["Open up the src/services/hello.ts file and add the following function, under the exising hello function:","As you can see, this function fetches a list of greetings from a fake API and returns the appropriate one. A Differential function can do anything a normal Node.js function can do, including making network requests."]},{"l":"2. Register the function with the service"},{"l":"3. Change the greet command to call the new function","p":["You can replace the greet.ts file with the following. We're just extending the existing command to take a new language parameter and call the new function."]},{"l":"4. Call the new command"}],[{"l":"Thinking in Differential","p":["Differential is a little bit different (pun intended) from the way it looks at separation of services from the way you might be used to.","It's built on the core beliefs that: Monolithic code does not need to result in co-located services.","It's not a RPC framework, or a microservices framework. If you're familiar with a service mesh, you can think of it as a higher-level, app-code aware service mesh."]},{"l":"The Differential Way","p":["1. Services are a collection of functions.","2. There are no restrictions on what these functions can do. They are just functions.","3. All services are co-located in the same codebase, so they can share code and types.","4. Starting a service is as simple as calling d.start(). Stopping is done via a d.stop().","You can have 1:1 services to processes, or you can have multiple services running in the same process. It's up to you. You can also start and stop services dynamically at runtime.","5. Once a service is started, it registers itself with the control-plane.","The open-source control-plane is a central service that keeps track of all the services that are running, and their health. It acts as a service registry, and a service bus.","6. You can call any function in any service from any other service.","You don't need to know where the service is running, or how to connect to it. You just need to know the name of the service and the name of the function.","7. Thanks to co-located code, your function calls are type-safe","You can't call a function that doesn't exist, or pass the wrong arguments.","8. Calling a function has the same ergonomics as calling a local function.","You can just call the function and it will return the result, even if it results in an Error. SDK and the control-plane routes the function call to the correct service, and does the proper serialization and deserialization of arguments and return values."]},{"i":"why","l":"Why?","p":["1. Monolithic codebases provide a great developer experience, but resulting monolithic services often do not.","2. Writing duplicative service interfaces/contracts can be avoided.","3. Anything a service has ever done can and should be represented by a single function definition.","4. Internal services should remain internal.","5. The disadvantages of a centralized control-plane are outweighed by the advantages.","A service bus that is aware of the application code can provide a better developer experience by offering type-safety and a single place to find all the services and their functions.","A service should stay internal until it's ready or necessary to be exposed externally. Starting a service on a port should be a conscious decision, not the default.","A type-safe language that can infer types should be able to infer the contract of a service from the service's implementation.","Communication via queues and pub/sub is a possible alternative, but it introduces complexities such as keeping track of channels:message types, message serialization, message delivery guarantees, and additional infrastructure configuration that lives outside of the code that does the work.","Differential is an opinionated framework. It makes some tradeoffs to make it easier to build services. They might not be the right tradeoffs for you, but we think they are the right tradeoffs for most people.","Every RPC framework introduces more complexity to deal with the impedance mismatch between the language and the wire format.","GraphQL has queries and mutations, but you need complex tooling to generate the types.","In REST, it's hard to model operations that doStuff().","Instead of n services talking to n services, a service bus allows streamlining the communication to a single service and fan-out from there.","Keeping unnecessary services running is wasteful. You can't just run the background processes; you have to run the entire service.","Modern RPC frameworks like gRPC and tRPC solve some of the problems, but they make different tradeoffs for stronger contracts and language/runtime interoperability.","Not having a compile step to generate contracts (e.g., protobufs) or a duplicative interface (tRPC) definition allows you to move faster.","Scaling a single service is hard. You can't scale just the background processes; you have to scale the entire service.","Such an architecture allows for a single place to implement cross-cutting concerns such as authentication, authorization, rate limiting, and observability.","Unless you're very careful, heavy background processes can affect the high availability of your mission-critical services."]}],[{"l":"Concepts"},{"l":"Service","p":["A collection of functions that can be called by a consumer using the differential client. Defined using the SDK."]},{"l":"Host","p":["A computer that you operate and own, that runs your services."]},{"l":"Cluster","p":["A group services that are running on a host. An API key is required to join a cluster."]},{"l":"Control Plane","p":["A central service that keeps track of all the services that are running, and their health. It acts as a service registry, and a service bus."]}],[{"l":"Architecture","p":["Differential is currently in technical preview. We've seen promising early results, but our architecture is still evolving. We welcome your thoughts on our design choices. Join the discussion on our GitHub.","Differential’s architecture is intentionally straightforward. We adhere to the principle that simplicity leads to easier scalability, self-hosting, and iterative improvements. Our focus is on refining simplicity to achieve the most effective abstractions."]},{"l":"Key Components","p":["Control Plane","SDK"]},{"l":"Control Plane","p":["The Control Plane functions as the nerve center, handling job management and API interactions. Each function call translates into a job, identified by its name and arguments. The Control Plane dynamically assigns jobs to clients, ensuring a single job isn't processed by multiple clients by atomically updating its state to \"Running\".","To prevent job stalling, the Control Plane monitors job durations, flagging any that exceed predefined limits as failed. These can be retried according to customizable policies. We use a relational database (compatible with Postgres, CockroachDB, etc.) for storing all job states, facilitating self-hosting."]},{"l":"SDK"},{"l":"Service-side","p":["On initializing a service, the SDK registers with the Control Plane and begins polling for jobs. It maintains an in-memory function registry and a task queue. This task queue, whose concurrency level is adjustable, determines parallel function execution capacity.","For each job, the SDK identifies the corresponding function and executes it with the provided arguments. Results are then relayed back to the Control Plane."]},{"l":"Client-side","p":["The client-side of Differential involves invoking functions through a type-safe client established via the SDK. Function calls are serialized and sent to the Control Plane. The client then long-polls for the result, which, upon receipt, is deserialized for use.","In all operations, we use msgpack for its efficiency in serialization over formats like JSON."]},{"l":"Considered Tradeoffs","p":["Long Polling: We chose long polling over persistent connections like websockets for easier self-hosting and scalability of the Control Plane. This decision, while impacting performance, is under continuous evaluation.","Database Selection: Our choice of Postgres for job state storage offers rapid iteration and ease in self-hosting. It strikes a balance between performance and flexibility.","Serialization with Msgpack: Msgpack offers a compact binary format, favoring speed over the compression level achieved by schema-aware binary formats. This decision eliminates the need for intermediate language schemas for developers to maintain."]},{"l":"Future Enhancements and Community Engagement","p":["Differential is a collaborative, evolving project. We actively integrate community feedback into our development process. Future enhancements will focus on improving performance, scalability, and user experience based on real-world applications and user suggestions.","If you're planning to use Differential, we'd love to hear from you. Please reach out to us at hello@differential.dev or join the discussion on our GitHub."]}],[{"l":"Argument and return values","p":["One benefit of using Differential is that is abstracts away many of the complexities of network and data serialization. However, as with any abstraction - it is optimised for the most common use-cases and leaks some of the underlying complexity in the form of limitations.","Differential serializes function arguments and return values with the same algorithm, so the limitations are the same for both."]},{"l":"Serializability","p":["Differential uses Message Pack for serializing function arguments and return values. It serializes the actual values, not the references to the values. Therefore, if your function arguments or return values contain references to objects, they will not be serialized correctly."]},{"l":"Data Type Compatibility","p":["This is a table of data types and their compatibility with Differential as validated by the test suite:","Data Type","Supported","undefined","✅","null","boolean","number","string","bigint","object","Array","Buffer","Date"]},{"l":"Advanced Data Types","p":["It is theoretically possible to pass more complex data types such as Map, Set, TypedArray, Error, RegExp, Function, Promise, Symbol, WeakMap, WeakSet, ArrayBuffer, SharedArrayBuffer, DataView, Int8Array, Uint8Array etc, as long as they are not nested and do not contain references to objects. However, they go through a serialization process that requires extra work to be properly deserialized on the other side.","For this purpose, they are left out of the initial offering."]},{"l":"Safety","p":["Differential adds a layer of safety by validating the data types of the function arguments and return values before serializing them. If the data types are not supported, Differential will throw an error DifferentialError.INVALID_DATA_TYPE. The peformance overhead of this validation is negligible. However, you can disable this behaviour by setting the validate option to false."]}],[{"l":"Comparisons"},{"i":"comparisons-with-http--rest-apis","l":"Comparisons with HTTP / REST APIs"},{"l":"Working with Data","p":["Unlike REST APIs, with Differential, you don't need to cocern yourself with the HTTP status codes, serialization, or deserialization. Differential works with native data types, and provide type-safe interfaces for you to work with.","This prevents the developer from having to deal with the conversion overhead between programming constructs and HTTP constructs.","With differential, the equivalent code here:","becomes:"]},{"l":"Working with Multiple Services","p":["In a service-oriented architecture, you may have multiple services that you need to communicate with. These will be exposed as different REST APIs, and your clients will communicate with them in a m:m fashion.","With Differential, all your services and clients connect to a single cluster. Clients can access any service that connects to the cluster. How the connections are mapped out, can be traced via the source code without an additional layer of network that gets in the way.","Differential becomes your service gateway and an elegant service discovery mechanism."]},{"l":"Exposure of Internal Functions","p":["A traditional REST service will require you to implement authentication, so your clients have a trusted relationship with your server. This is usually done via a token-based authentication scheme, and middleware that checks for the token on every request. This is especially true if you can't trust the network that your clients are connecting from, such as outside of your VPC.","With Differential, your internal services are only exposed to the control-plane via a secure connection. This means that you don't need to implement authentication for your internal services, as they are not exposed to the outside world. Differential clients can only access the functions that you explicitly expose to them."]},{"l":"Type Safety","p":["Differential provides type-safe interfaces for your clients to interact with your services, without a compile step. This also means that you don't have to worry about intermediate representations like OpenAPI, and the overhead of maintaining them."]},{"l":"Language Agnosticism","p":["Differential is not language agnostic. If you need to connect two services written in different languages, you will need to implement a shim layer in Typescript, and connect them to the same cluster. Depending on your use case, this may be additional complexity that you don't need.","This is in stark contrast to something like a REST service that can publish a intermediary representation of its API, such as OpenAPI, and allow clients to generate code from it. This is a tradeoff that we have made, as we believe that the benefits of type safety outweigh the benefits of language agnosticism."]},{"i":"comparisons-with-grpc--protocol-buffers","l":"Comparisons with gRPC / Protocol Buffers"},{"i":"working-with-data-1","l":"Working with Data","p":["gRPC uses Protocol Buffers as its serialization format. This means that you need to define your data structures in a separate file, and compile them into your language of choice. This is an additional step that you need to perform, and build tooling towards.","Every change that is made to the data structures will require a recompilation of the data structures, and a redeployment of the service.","Differential uses native programming constructs, and does not require you to have a comparative .proto file or a complilation step. Compatibility of contracts is enforced by the type system. However, you do lose out on some of the gurantees that Protocol Buffers provides, such as backwards compatibility.","However, we do plan to support additional developer tooling that will optionally verify and protect against breaking changes in contracts."]},{"l":"Serialization","p":["Protocol Buffers uses its knowledge about the data structure to optimize the serialization, deserialization, and the message size over the wire. Differential does not have this knowledge, and uses msgpack (a binary serialization format) to serialize and deserialize data. This means that the message size over the wire will be typically larger than gRPC, but smaller than JSON."]},{"l":"Other notes","p":["The same notes that apply to REST APIs also apply to gRPC APIs for Working with Multiple Services, Exposure of Internal Functions, Type Safety, and Language Agnosticism."]}],[{"l":"Distributed Caching","p":["Status: General Availability","Differential is useful for caching expensive operations and speeding up you application by storing returned values in the control-plane. It's then available to be used by other calls, without having to call the function again.","Differential supports global caching via a convenience function called cached. It takes a function, and a ttl in milliseconds and returns a new function that prompts the user to provide a cache key. If the function has already been called with that key, it will return the same result as before.","To mark a function as cached, simply wrap it with the cached function.","Now, when you call the function, you must provide a cache key.","If you call the function again with the same cache key, the previous result will be returned.","One question you might have is why the client function call has to provide the cache key. The reason for this is two-fold:","Control-plane doesn't have to compute the cache key at the time of job distribution, which is a performance optimization.","Security features such as end to end encryption still work, as the cache key is not visible to the control-plane."]}],[{"l":"End to End Encryption","p":["You might wish to encrypt all function arguments and return values, so that the control plane cannot see them. This is possible with Differential, but it requires you to configure your own encryption keys.","These encryption keys are used to encrypt and decrypt the function arguments and return values. The control plane does not have access to these keys.","The Typescript example below shows how to configure your own encryption keys.","It accepts an array of encryption keys. This is useful if you want to rotate your encryption keys. Differential will try to decrypt the function arguments and return values with each encryption key until it finds one that works.","Since this essentially makes function arguments opaque to the control plane, it is important to note that Differential will not be able to provide any of its usual features for these encrypted function arguments, such as predictive retries or predictive alerting.","Caching is still supported, as it is based on the function arguments and return values as supplied by the client."]}],[{"l":"Failure Modes and Error Handling","p":["Differential failure modes and error handling is not too dissimilar from the traditional failure modes and error handling in a service-oriented architecture."]},{"l":"A function call results in a rejection","p":["When a promise gets rejected from a remote function, Differential will serialize the error and send it back to the caller. The caller can then handle the error as needed.","Differential does not do any retries or error handling on behalf of the caller in this case. It is up to the caller to decide how to handle the error.","However, Differential does serialize the error and send it back to the caller, which allows the caller to handle the error as needed.","For example, given this service function:","The caller can handle the error like this:"]},{"l":"Stack trace","p":["Differential does preserve the stack trace that is generated when the error is thrown, in the remote function."]},{"l":"Error prototype","p":["Differential does preserve the prototype of all the native JavaScript errors as defined in the Well-Known Intrinsic Objects. This means that the caller can check the error type using the instanceof operator for these errors.","However, custom errors are not preserved across the boundary. This means that the caller cannot check the error type using the instanceof operator for custom errors. However, the caller can still check the class properties of the error to determine the error type - such as the name and message properties."]},{"l":"A function call results in a timeout","p":["When a function call results in a timeout, Differential will reject the promise with a DifferentialError, with a message of DifferentialError.REMOTE_EXECUTION_ERROR. The caller can then handle the error as needed."]},{"l":"A function call results in continued machine failure","p":["Differential can detect when a machine has stopped responding and will automatically failover to another machine. This also means that the functions that were running on the failed machine will be marked as stalled, so that they can be re-executed on another machine.","By default, a cluster will auto-retry a stalled function up to 3 times. If the function still fails after 3 retries, the function will be marked as failed and the caller will receive a DifferentialError with a message of DifferentialError.REMOTE_EXECUTION_ERROR.","Differential will prevent retrying the function indefinitely, to prevent a machine from continuously failing."]},{"l":"Network gets interrupted during a function call","p":["When the network gets interrupted during a function call, Differential will try to re-establish the connection to the control-plane.","Once the connection is re-established, the caller will continue to poll the control-plane for the results of the function. If the function has already completed, the caller will receive the results as expected.","In case of repeated failures, the number of cycles that Differential will try to re-establish the connection is configured via ResultsPoller.MAX_ERROR_CYCLES in the client. By default, this is set to 5, spaced out over 250 seconds. If the connection is not re-established after the configured number of cycles, the function will be marked as failed and the caller will receive a DifferentialError with a message of DifferentialError.TOO_MANY_NETWORK_ERRORS."]}],[{"l":"Idempotency","p":["Idempotency is a property of an operation that means the operation can be applied multiple times without changing the result beyond the initial application. In other words, making the same request multiple times has the same effect as making the request once.","In the context of Differential, you can easily achive this by the combination of:","Retrying the function call if it gets rejected, which would allow you ensure at-least-once execution.","Checking a unique identifier in the request to ensure that the operation is not applied multiple times.","The following is an example of how you can implement idempotency:"]},{"l":"Guarding against duplicate requests due to stalled machine retries","p":["If a machine processing a request stalls, Differential will retry the request on another machine. This can lead to the same request being processed multiple times. To guard against this, you must use a unique identifier in the execution chain and check if the operation has already been applied explicitly."]}],[{"l":"Limitations"},{"l":"Programming language","p":["Differential only supports TypeScript until it gets to a stable release. We do plan to support other languages in the future, however we are intensely focused on creating the right abstractions for a single language first.","There's nothing preventing your from using Differential with JavaScript, however you will lose out on the type safety that Differential provides for your clients."]}],[{"l":"Monolith to Microservices and Back","p":["A key value proposition of Differential is that it makes it easy to break up your monolith into services. This is a big deal, because breaking up a monolith is traditionally a very high overhead process. Differential makes it easy to break up your monolith into services, and to change the boundaries of your services as your business requirements change.","It also makes it easy to hit \"Abort\" and go back to a monolith if you need to."]},{"l":"The Problem","p":["You have a well-architected monolith. You've determined that it's time to break it up into 2 or more services. But the overhead of going for a service-oriented/microservices architecture is traditionally very high. You have to:","Figure out which functionality to break out into a service","Split up the code","Decide on a service communication protocol (HTTP, gRPC, tRPC, etc)","Copy paste boilerplate code for each service and/or write libraries to abstract away the boilerplate","Set up obervability / health checks / etc for each service","Write/move the business logic for each service","Write the service interfaces for each service (e.g. protobufs, OpenAPI, ts-rest/zod)","Document the interplay of services for other developers","This is a lot of work, and it's not even the fun part of building a product. If business requirements change and you need to change the boundaries of your services, you have to do it all over again."]},{"i":"this-leads-many-engineering-teams-to","l":"This leads many engineering teams to:","p":["Delay breaking up their monoliths when it would be beneficial to do so, or...","Break it up early and suffer the consequences of a poorly architected services architecture."]},{"l":"The Solution","p":["✅ Differential abstracts this away from you, unless you want to look under the hood. It uses HTTP.","✅ Differential comes with a dev console which gives you full observability down to the function level. You can see errors, detailed logs and execution times with zero-setup.","✅ Differential infers your service interface from your function types. Your services become end-to-end typesafe. There's no need for another interchange format.","✅ Differential provides you with the tools to keep your code co-located, but deployable as independent services at runtime.","✅ Differential services are simply javascript objects that define which functions (a.k.a business logic) belong to which service.","✅ Differential's dev console gives you a full view of your service registry, which functions are registered, and the live status for each.","✅ With Differential, you don't have to split up your codebase.","\uD83D\uDC4D This is the highest-value problem worth solving. Differential helps you focus on this problem.","Copy/Paste boilerplate code for each service and/or write libraries to abstract away the boilerplate.","Decide on a service communication protocol (HTTP, gRPC, tRPC, etc.).","Differential is an application code aware service mesh, and a distributed orchestrator. It is designed to:","Document the interplay of services for other developers.","Figure out which functionality to break out into a service.","Make it easy to break up your monolith into services","Make it easy to change the boundaries of your services as your business requirements change","Make it easy to hit \"Abort\" and go back to a monolith if you need to","Problem","Set up observability / health checks / monitoring for each service.","Solution","Split up the codebase","Write the service interfaces for each service (e.g. protobufs, OpenAPI, ts-rest/zod).","Write/move business logic for each service."]}],[{"l":"Observability","p":["Status: In Development","Differential comes with built-in observability that allows you to see what's happening in your services in real-time, with zero configuration. You can see live payloads, events, and errors in the Differential dashboard, right down to a function call - or up to a cluster level.","To access telemetry data, you can use the Differential dashboard, with support for the CLI coming soon."]}],[{"l":"On-demand Compute","p":["Status: In Development","On-demand compute is Differential's managed compute offering that runs your Differential services on-demand in a serverless setting.","Since the control-plane has the knowledge of how many function calls are being made and how frequently, it can use this information to spin up the service on-demand and scale it down when it's not being used.","Because a single service session can execute multiple function calls, you don't have to worry about the cold start time of the function. The service will be kept warm for a certain period of time after the last function call.","On-demand compute is currently in development and will be available soon. To gain early access, please sign up for the waitlist here."]}],[{"l":"Predictive Alerting","p":["Status: In Development","Differential can predict if a function is failing due to an unrecoverable error that requires a code change, and alert you with reproduction steps.","The control-plane has all the required context on a particular failure, when it happens. It knows the function, some metadata about the source, payload, and the error message. It can use this information to predict if the error is unrecoverable or not.","If it's predicted to be unrecoverable, Differential will alert you prompting to make the necessary code change. This is especially useful for errors that are hard to reproduce, and require a code change to fix.","For example, let's consider this that occurs due to a data inconsistency:","In this case, Differential can predict that the error is unrecoverable, and prompt you to make a code change. It will provide you with the exact payload that caused the error, and the reproduction steps to reproduce the error locally."]}],[{"l":"Predictive Retries","p":["Status: Technical Preview","This feature is at the Technical Preview stage. Due to the nature of probabilistic outcomes, this feature may result in non-deterministic behaviour. It's opt-in and switched off by default.","Differential can predict transient errors and retry the operations without the developer having to write custom code.","The control-plane has all the required context on a particular failure, when it happens. It knows the function, some metadata about the source, payload, and the error message. It can use this information to predict if the error is transient or not.","If it's predicted to be transient, Differential will retry the operation on a healthy worker before the client even notices. This is especially useful for database deadlocks, network errors, and other transient errors.","It's worth noting that Differential doesn't retry the operation indefinitely. It has a retry limit for any function call that results in a transient error (default 3 times). If the function fails more than the retry limit, Differential will mark the function as permanently failed.","For example, let's consider this that occurs due to a database deadlock:","You can turn this feature on for your cluster using the Console. It's off by default."]}],[{"l":"Recovering from machine failures","p":["Status: General Availability","In a cloud environment, machines can fail at any time. Differential transparently handles machine failures by periodically sending heartbeats to the control-plane, quickly catching and retrying failed operations on a healthy worker. This means that you don't have to worry about your service being unavailable due to a machine failure.","If a machine fails to send any heartbeats within an interval (default 90 seconds):","It is marked as unhealthy, and Differential will not send any new requests to it.","The functions in progress are marked as failed, and Differential will retry them on a healthy worker.","If the machine comes back online, Differential will mark it as healthy, and start sending new requests to it. However, it will disregard any results from the machine for the functions that were marked as failed.","However, it's possible that the particular workload that you're executing on the machine is what makes it crash. To account for this, there's a retry limit for any function call that results in a machine stall (default 2 times). If the function fails more than the retry limit, Differential will mark the function as permanently failed."]}],[{"l":"Self-hosting","p":["You can self-host the Differential control-plane using your own compute, as long as you can run a Docker container. Differential only requires a postgres database for persistence."]},{"i":"guide-to-self-hosting-using-flyio","l":"Guide to self-hosting using fly.io"},{"l":"Creating the fly app","p":["Clone the repo:","Create a fly app, and note the app name:","Open the fly.toml file and replace differential-core with the app name you noted in the previous step.","Deploy to fly.io:","You will need to set a secret to access to the management functions of the control-plane. We will save the secret to a management-secret.txt file for now. You can do this by running:"]},{"l":"Creating the postgres instance","p":["Next, you will need to provision a postgres instance. You can use any postgres provider, but for this purpose, we will use fly postgres. Note the fly postgres app name when you create it.","Attach the postgres instance to the fly app. This will set the DATABASE_URL environment variable in the fly app."]},{"l":"Creating your first cluster","p":["Assuming the app is created and the postgres instance is attached, you can now create your first cluster. Assuming your app is exposed at differential-core.fly.dev, you can create a cluster by running:","Now, you can retrieve the cluster information by running:","You will only need the apiSecret from the response."]},{"l":"Connecting to the control-plane","p":["To connect to the cluster, you need:","The Typescript SDK","The endpoint where the control-plane is hosted","The apiSecret from the previous step","When initializing the SDK, you will need to pass the apiSecret and the endpoint to the Differential class.","And that's it!"]},{"l":"Additional infrastructure resources","p":["Some Differential features require additional infrastructure resources, these include:","Client library registry","Cloud deployments","In order to take advantage of these features, you will need to provision the associated resources and provide the control-plane with access."]},{"l":"Previsioning CloudFormation resources","p":["Infrastructure as code (IaC) definitions for all additional resources, as well as instructions for provisioning them reside in ./infrastructure."]},{"l":"Providing the control-plane with AWS access","p":["The stack created in the previous step, provisions an IAM User with the name DifferentialControlPlane that has IAM permissions to interact with resources hosted in AWS.","Create an Access Key using the AWS CLI's create-access-key command which can be used by the control-plane.","Create the access key for DifferentialControlPlane","Take note of the AccessKeyId and SecretAccessKey","Add the AccessKeyId and SecretAccessKey as Fly.io secrets"]}],[{"l":"Service Discovery","p":["Status: General Availability","Differential comes with a built-in service registry, so you can call your services by name, without having to worry about IP addresses, ports, or where it's deployed. Your services phone-home to Differential control-plane.","Your services (whether running in your own compute or Differential cloud) always poll the control-plane to:","Advertise their presence","Advertise their health","Ask for work","This allows you to deploy your services anywhere, even across multiple cloud providers and regions, and still have them communicate with each other without any networking configuration.","It also cuts down the need to secure your services with service to service authentication, as the machines are not directly communicating with each other, or accepting incoming connections. This improves the security posture of your services."]}],[{"l":"Shared Client Libraries","p":["Status: Private Beta","Differential supports publishing a client library for your cluster which can be included in a separate project using npm. Client libraries are distributed privately via a node package registry managed by Differential.","The Differential CLI is used to manage client libraries, you can publish a new client library with the client publish command.","Differential uses semantic versioning, as part of publishing the client library you will be asked to describe the change increment ( patch, minor, majod).","Once published, the client can be installed in other projects as you would any other node package.","The differential auth login CLI command configures the host's ~/.npmrc configuration to authenticate with the Differential package registry. If you need to install the package from another host, run npm auth login.","This will provide a type safe client which can be used to call any service in the cluster.","Shared client libraries are currently in private beta and will be available soon. To gain early access, please sign up for the waitlist here."]}],[{"l":"Typescript SDK","p":["This is the official Differential SDK for Typescript."]},{"l":"Installation"},{"l":"npm"},{"l":"yarn"},{"l":"pnpm"},{"l":"Quick Start"},{"l":"1. Initializing Differential","p":["Create a file named d.ts which will be used to initialize Differential. This file will export the Differential instance."]},{"l":"2. Hello World Service","p":["In a separate file, create the \"Hello World\" service. This file will import the Differential instance from d.ts and define the service."]},{"l":"3. Calling the Service","p":["When calling the service, use the typeof generic to ensure type safety. This can be done in any file where you need to call the service, like a test file or another service file."]},{"l":"4. Running the Service","p":["To run the service, simply run the file with the service definition. This will start the service and make it available to other services.","and then you can invoke the service from another file:"]},{"l":"Documentation","p":["Differential documentation contains all the information you need to get started with Differential."]},{"l":"Examples","p":["Monolith contains an example of a monolith application broken into multiple services.","End to end encryption contains an example of how to use Differential's end to end encryption.","Caching contains an example of how to use Differential's distributed caching."]}],[{"i":"class-differential","l":"Class: Differential","p":["The Differential client. This is the main entry point for using Differential.","Differential client exposes two main methods:","service- Registers a service with Differential. This will register all functions on the service.","client- Provides a type safe client for performing calls to a registered service.","Example"]},{"l":"Table of contents"},{"l":"Constructors","p":["constructor"]},{"l":"Methods","p":["client","service"]},{"i":"constructors-1","l":"Constructors"},{"l":"constructor","p":["• new Differential( apiSecret, options?): Differential","Initializes a new Differential instance."]},{"l":"Parameters","p":["Name","Type","Description","apiSecret","string","The API Secret for your Differential cluster. You can obtain one from https://api.differential.dev/demo/token.","options?","Object","Additional options for the Differential client.","options.encryptionKeys?","Buffer[]","An array of encryption keys to use for encrypting and decrypting data. These keys are never sent to the control-plane and allows you to encrypt function arguments and return values. If you do not provide any keys, Differential will not encrypt any data. Encryption has a performance impact on your functions. When you want to rotate keys, you can add new keys to the start of the array. Differential will try to decrypt data with each key in the array until it finds a key that works. Differential will encrypt data with the first key in the array. Each key must be 32 bytes long.","options.endpoint?","The endpoint for the Differential cluster. Defaults to https://api.differential.dev."]},{"l":"Returns","p":["Differential","Example"]},{"l":"Defined in","p":["ts-core/src/Differential.ts:410"]},{"i":"methods-1","l":"Methods"},{"l":"client","p":["▸ client< T>( service): ServiceClient< T>","Provides a type safe client for performing calls to a registered service. Waits for the function to complete before returning, and returns the result of the function call."]},{"l":"Type parameters","p":["Name","Type","T","extends RegisteredService< any>"]},{"i":"parameters-1","l":"Parameters","p":["Name","Type","service","T[definition][name]"]},{"i":"returns-1","l":"Returns","p":["ServiceClient< T>","ServiceClient","Example"]},{"i":"defined-in-1","l":"Defined in","p":["ts-core/src/Differential.ts:542","▸ client< T>( service, options): BackgroundServiceClient< T>","Provides a type safe client for performing calls to a registered service. Waits for the function to complete before returning, and returns the result of the function call."]},{"i":"type-parameters-1","l":"Type parameters","p":["Name","Type","T","extends RegisteredService< any>"]},{"i":"parameters-2","l":"Parameters","p":["Name","Type","service","T[definition][name]","options","Object","options.background","true"]},{"i":"returns-2","l":"Returns","p":["BackgroundServiceClient< T>","ServiceClient","Example"]},{"i":"defined-in-2","l":"Defined in","p":["ts-core/src/Differential.ts:546"]},{"l":"service","p":["▸ service< T, N>( service): RegisteredService< T>","Registers a service with Differential. This will register all functions on the service."]},{"i":"type-parameters-2","l":"Type parameters","p":["Name","Type","T","extends ServiceDefinition< N>","N","extends string"]},{"i":"parameters-3","l":"Parameters","p":["Name","Type","Description","service","T","The service definition."]},{"i":"returns-3","l":"Returns","p":["RegisteredService< T>","A registered service instance.","Example"]},{"i":"defined-in-3","l":"Defined in","p":["ts-core/src/Differential.ts:518"]}]]